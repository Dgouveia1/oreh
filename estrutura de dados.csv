categoria,objeto,detalhes
1. TABELAS E COLUNAS,TABELA: admin_users,COLUNA: affiliate_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: admin_users,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: admin_users,COLUNA: email | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: admin_users,COLUNA: name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: admin_users,COLUNA: role | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: admin_users,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: uuid_generate_v4() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliate_legal_documents,COLUNA: last_updated_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliate_legal_documents,COLUNA: payment_policy | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliate_legal_documents,COLUNA: id | TIPO: smallint | NULÁVEL: NO | PADRÃO: 1 | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliate_legal_documents,COLUNA: affiliate_terms | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: hotmart_code | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: payment_info | TIPO: jsonb | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: commission_rate | TIPO: numeric | NULÁVEL: YES | PADRÃO: 0.20 | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: address | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: phone | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: cpf_cnpj | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: contact_email | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: affiliates,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ai_token_usage,COLUNA: user_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ai_token_usage,COLUNA: chat_id | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ai_token_usage,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ai_token_usage,COLUNA: id | TIPO: bigint | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ai_token_usage,COLUNA: tokens_used | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ai_token_usage,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: message | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: metadata | TIPO: jsonb | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: id | TIPO: bigint | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: level | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: company_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: app_logs,COLUNA: user_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: lead_value | TIPO: numeric | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: customer_phone | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: last_message_summary | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: status | TIPO: text | NULÁVEL: YES | PADRÃO: '''Atendimento''::text'::text | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: updated_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: uuid_generate_v4() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: temperatura | TIPO: text | NULÁVEL: YES | PADRÃO: 'TOPO DO FUNIL'::text | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: customer_name | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: chats,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: email | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: name | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: status | TIPO: text | NULÁVEL: YES | PADRÃO: 'Lead'::text | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: origin | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: location | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: updated_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: notes | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: is_personal | TIPO: boolean | NULÁVEL: YES | PADRÃO: false | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: gen_random_uuid() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: clients,COLUNA: phone | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: asaas_subscription_id | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: plan_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: '83a6e00d-67d6-4301-b96c-c1bb51ab3f80'::uuid | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: affiliate_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: Identifica o afiliado responsável pela empresa/cliente.
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: used_coupon_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: Registra o ID do cupom de desconto utilizado pelo cliente no momento da assinatura.
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: uuid_generate_v4() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: official_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: cnpj | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: industry | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: corporate_email | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: phone | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: address | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: asaas_customer_id | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: companies,COLUNA: status | TIPO: text | NULÁVEL: YES | PADRÃO: 'onboarding'::text | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: evolution_number | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: ai_agent_function | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: ai_language_complexity | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: evolution_api_url | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: evolution_api_key | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: ai_tone_adaptability | TIPO: boolean | NULÁVEL: YES | PADRÃO: true | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: base_prompt | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: is_ai_active | TIPO: boolean | NULÁVEL: YES | PADRÃO: true | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: business_info | TIPO: jsonb | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: evolution_instance_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: ai_personality_style | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: ai_dominant_traits | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_secrets,COLUNA: ai_tone_formality | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: company_status | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: official_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: plan_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: affiliate_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: affiliate_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: company_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: plan_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: user_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: company_created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: user_role | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: last_synced_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: contact_email | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: company_user_details_sync,COLUNA: contact_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: discount_value | TIPO: numeric | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: usage_limit | TIPO: integer | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: usage_count | TIPO: integer | NULÁVEL: NO | PADRÃO: 0 | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,"COLUNA: applicable_plan_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: Se nulo, o cupom se aplica a todos os planos."
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: expires_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: code | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: discount_type | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: Tipo de desconto: 'percentage' para percentual ou 'fixed' para valor fixo.
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: campaign_name | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: gen_random_uuid() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: coupons,COLUNA: is_active | TIPO: boolean | NULÁVEL: NO | PADRÃO: true | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: documents,COLUNA: id | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: documents,COLUNA: metadata | TIPO: jsonb | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: documents,COLUNA: company_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: documents,COLUNA: content | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: documents,COLUNA: embedding | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: documents,COLUNA: file_path | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: local | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: telefone | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: data | TIPO: date | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: hora_inicio | TIPO: time without time zone | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: hora_fim | TIPO: time without time zone | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: cliente | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: assunto | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: events,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ingestion_queue,COLUNA: updated_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ingestion_queue,COLUNA: status | TIPO: text | NULÁVEL: YES | PADRÃO: 'pending'::text | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ingestion_queue,COLUNA: company_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ingestion_queue,COLUNA: file_path | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ingestion_queue,COLUNA: id | TIPO: bigint | NULÁVEL: NO | PADRÃO: nextval('ingestion_queue_id_seq'::regclass) | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: ingestion_queue,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: legal_documents,COLUNA: terms_of_use | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: legal_documents,COLUNA: id | TIPO: smallint | NULÁVEL: NO | PADRÃO: 1 | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: legal_documents,COLUNA: last_updated_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: legal_documents,COLUNA: privacy_policy | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: legal_documents,COLUNA: membership_agreement | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: n8n_chat_histories,COLUNA: message | TIPO: jsonb | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: n8n_chat_histories,COLUNA: id | TIPO: integer | NULÁVEL: NO | PADRÃO: nextval('n8n_chat_histories_id_seq'::regclass) | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: n8n_chat_histories,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: n8n_chat_histories,COLUNA: session_id | TIPO: character varying(255) | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: onboarding_data,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: onboarding_data,COLUNA: responses | TIPO: jsonb | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: onboarding_data,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: onboarding_data,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: gen_random_uuid() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: price | TIPO: numeric | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: name | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: description | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: Descrição detalhada do que o plano inclui.
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: max_users | TIPO: integer | NULÁVEL: YES | PADRÃO: 1 | DESCRIÇÃO: Número máximo de usuários permitidos neste plano.
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: monthly_chat_limit | TIPO: integer | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: uuid_generate_v4() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: is_active | TIPO: boolean | NULÁVEL: YES | PADRÃO: true | DESCRIÇÃO: Se o plano está ativo e pode ser selecionado.
1. TABELAS E COLUNAS,TABELA: plans,COLUNA: show_on_onboarding | TIPO: boolean | NULÁVEL: YES | PADRÃO: true | DESCRIÇÃO: Indica se o plano deve ser exibido na tela de seleção durante o onboarding.
1. TABELAS E COLUNAS,TABELA: products,COLUNA: name | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: company_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: gen_random_uuid() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: description | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: purchase_link | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: photo_urls | TIPO: jsonb | NULÁVEL: YES | PADRÃO: '[]'::jsonb | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: products,COLUNA: value | TIPO: numeric | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: ip_address | TIPO: inet | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: gen_random_uuid() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: email | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: acceptance_type | TIPO: text | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: Indica se o aceite foi de um usuário comum (user) ou de um afiliado (affiliate).
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: terms_version | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: Timestamp da coluna last_updated_at da tabela legal_documents ou affiliate_legal_documents correspondente.
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: geolocation_lon | TIPO: numeric | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: geolocation_lat | TIPO: numeric | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: user_id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: terms_acceptances,COLUNA: accepted_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: NO | PADRÃO: now() | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: email | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: full_name | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: userinitial | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: company_id | TIPO: uuid | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: id | TIPO: uuid | NULÁVEL: NO | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,COLUNA: job_title | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: users,"COLUNA: role | TIPO: text | NULÁVEL: YES | PADRÃO: 'app_user'::text | DESCRIÇÃO: Define o perfil do usuário (ex: app_user, affiliate, admin)"
1. TABELAS E COLUNAS,TABELA: v_n8n_chat_histories_clean,COLUNA: id | TIPO: integer | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: v_n8n_chat_histories_clean,COLUNA: clean_message | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: v_n8n_chat_histories_clean,COLUNA: session_id | TIPO: character varying(255) | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: v_n8n_chat_histories_clean,COLUNA: original_message_type | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: v_n8n_chat_histories_clean,COLUNA: sender | TIPO: text | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: v_n8n_chat_histories_clean,COLUNA: created_at | TIPO: timestamp with time zone | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
1. TABELAS E COLUNAS,TABELA: v_total_clients,COLUNA: count | TIPO: bigint | NULÁVEL: YES | PADRÃO: N/A | DESCRIÇÃO: N/A
2. CONSTRAINTS (CHAVES),TABELA: admin_users,CONSTRAINT: admin_users_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: admin_users,CONSTRAINT: admin_users_affiliate_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): affiliate_id | REFERENCIA: affiliates(id)
2. CONSTRAINTS (CHAVES),TABELA: admin_users,CONSTRAINT: admin_users_email_key | TIPO: UNIQUE | COLUNA(S): email
2. CONSTRAINTS (CHAVES),TABELA: affiliate_legal_documents,CONSTRAINT: affiliate_legal_documents_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: affiliates,CONSTRAINT: affiliates_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): id | REFERENCIA: users(id)
2. CONSTRAINTS (CHAVES),TABELA: affiliates,CONSTRAINT: affiliates_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: ai_token_usage,null
2. CONSTRAINTS (CHAVES),TABELA: ai_token_usage,CONSTRAINT: ai_token_usage_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: ai_token_usage,CONSTRAINT: ai_token_usage_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: app_logs,CONSTRAINT: app_logs_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: app_logs,null
2. CONSTRAINTS (CHAVES),TABELA: app_logs,CONSTRAINT: app_logs_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: chats,CONSTRAINT: chats_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: chats,CONSTRAINT: chats_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: clients,CONSTRAINT: clients_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: clients,CONSTRAINT: clients_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: companies,CONSTRAINT: companies_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: companies,CONSTRAINT: companies_plan_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): plan_id | REFERENCIA: plans(id)
2. CONSTRAINTS (CHAVES),TABELA: companies,CONSTRAINT: companies_cnpj_key | TIPO: UNIQUE | COLUNA(S): cnpj
2. CONSTRAINTS (CHAVES),TABELA: companies,CONSTRAINT: companies_affiliate_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): affiliate_id | REFERENCIA: affiliates(id)
2. CONSTRAINTS (CHAVES),TABELA: companies,CONSTRAINT: fk_used_coupon | TIPO: FOREIGN KEY | COLUNA(S): used_coupon_id | REFERENCIA: coupons(id)
2. CONSTRAINTS (CHAVES),TABELA: company_secrets,CONSTRAINT: company_secrets_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: company_secrets,CONSTRAINT: company_secrets_pkey | TIPO: PRIMARY KEY | COLUNA(S): company_id
2. CONSTRAINTS (CHAVES),TABELA: company_user_details_sync,CONSTRAINT: company_user_details_sync_pkey | TIPO: PRIMARY KEY | COLUNA(S): company_id
2. CONSTRAINTS (CHAVES),TABELA: coupons,CONSTRAINT: coupons_code_key | TIPO: UNIQUE | COLUNA(S): code
2. CONSTRAINTS (CHAVES),TABELA: coupons,CONSTRAINT: coupons_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: coupons,CONSTRAINT: coupons_applicable_plan_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): applicable_plan_id | REFERENCIA: plans(id)
2. CONSTRAINTS (CHAVES),TABELA: documents,CONSTRAINT: documents_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: documents,CONSTRAINT: documents_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: events,CONSTRAINT: events_pkey | TIPO: PRIMARY KEY | COLUNA(S): telefone
2. CONSTRAINTS (CHAVES),TABELA: events,CONSTRAINT: events_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: ingestion_queue,CONSTRAINT: ingestion_queue_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: ingestion_queue,CONSTRAINT: ingestion_queue_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: legal_documents,CONSTRAINT: legal_documents_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: n8n_chat_histories,CONSTRAINT: n8n_chat_histories_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: onboarding_data,CONSTRAINT: onboarding_data_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: onboarding_data,CONSTRAINT: onboarding_data_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: plans,CONSTRAINT: plans_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: products,CONSTRAINT: products_company_id_fkey | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: products,CONSTRAINT: products_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: terms_acceptances,CONSTRAINT: terms_acceptances_pkey | TIPO: PRIMARY KEY | COLUNA(S): id
2. CONSTRAINTS (CHAVES),TABELA: terms_acceptances,null
2. CONSTRAINTS (CHAVES),TABELA: users,null
2. CONSTRAINTS (CHAVES),TABELA: users,CONSTRAINT: users_company_id_fkey1 | TIPO: FOREIGN KEY | COLUNA(S): company_id | REFERENCIA: companies(id)
2. CONSTRAINTS (CHAVES),TABELA: users,CONSTRAINT: users_email_key1 | TIPO: UNIQUE | COLUNA(S): email
2. CONSTRAINTS (CHAVES),TABELA: users,CONSTRAINT: users_pkey1 | TIPO: PRIMARY KEY | COLUNA(S): id
3. ÍNDICES,TABELA: admin_users,ÍNDICE: admin_users_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX admin_users_pkey ON public.admin_users USING btree (id)
3. ÍNDICES,TABELA: admin_users,ÍNDICE: admin_users_email_key | DEFINIÇÃO: CREATE UNIQUE INDEX admin_users_email_key ON public.admin_users USING btree (email)
3. ÍNDICES,TABELA: affiliate_legal_documents,ÍNDICE: affiliate_legal_documents_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX affiliate_legal_documents_pkey ON public.affiliate_legal_documents USING btree (id)
3. ÍNDICES,TABELA: affiliates,ÍNDICE: affiliates_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX affiliates_pkey ON public.affiliates USING btree (id)
3. ÍNDICES,TABELA: ai_token_usage,ÍNDICE: ai_token_usage_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX ai_token_usage_pkey ON public.ai_token_usage USING btree (id)
3. ÍNDICES,TABELA: app_logs,ÍNDICE: app_logs_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX app_logs_pkey ON public.app_logs USING btree (id)
3. ÍNDICES,TABELA: chats,ÍNDICE: chats_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX chats_pkey ON public.chats USING btree (id)
3. ÍNDICES,TABELA: clients,ÍNDICE: clients_company_id_idx | DEFINIÇÃO: CREATE INDEX clients_company_id_idx ON public.clients USING btree (company_id)
3. ÍNDICES,TABELA: clients,ÍNDICE: clients_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX clients_pkey ON public.clients USING btree (id)
3. ÍNDICES,TABELA: companies,ÍNDICE: companies_cnpj_key | DEFINIÇÃO: CREATE UNIQUE INDEX companies_cnpj_key ON public.companies USING btree (cnpj)
3. ÍNDICES,TABELA: companies,ÍNDICE: companies_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX companies_pkey ON public.companies USING btree (id)
3. ÍNDICES,TABELA: company_secrets,ÍNDICE: company_secrets_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX company_secrets_pkey ON public.company_secrets USING btree (company_id)
3. ÍNDICES,TABELA: company_user_details_sync,ÍNDICE: idx_company_details_sync_affiliate | DEFINIÇÃO: CREATE INDEX idx_company_details_sync_affiliate ON public.company_user_details_sync USING btree (affiliate_id)
3. ÍNDICES,TABELA: company_user_details_sync,ÍNDICE: company_user_details_sync_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX company_user_details_sync_pkey ON public.company_user_details_sync USING btree (company_id)
3. ÍNDICES,TABELA: company_user_details_sync,ÍNDICE: idx_company_details_sync_status | DEFINIÇÃO: CREATE INDEX idx_company_details_sync_status ON public.company_user_details_sync USING btree (company_status)
3. ÍNDICES,TABELA: coupons,ÍNDICE: coupons_code_key | DEFINIÇÃO: CREATE UNIQUE INDEX coupons_code_key ON public.coupons USING btree (code)
3. ÍNDICES,TABELA: coupons,ÍNDICE: coupons_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX coupons_pkey ON public.coupons USING btree (id)
3. ÍNDICES,TABELA: documents,ÍNDICE: documents_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX documents_pkey ON public.documents USING btree (id)
3. ÍNDICES,TABELA: documents,ÍNDICE: idx_documents_file_path | DEFINIÇÃO: CREATE INDEX idx_documents_file_path ON public.documents USING btree (file_path)
3. ÍNDICES,TABELA: events,ÍNDICE: events_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX events_pkey ON public.events USING btree (telefone)
3. ÍNDICES,TABELA: ingestion_queue,ÍNDICE: ingestion_queue_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX ingestion_queue_pkey ON public.ingestion_queue USING btree (id)
3. ÍNDICES,TABELA: legal_documents,ÍNDICE: legal_documents_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX legal_documents_pkey ON public.legal_documents USING btree (id)
3. ÍNDICES,TABELA: n8n_chat_histories,ÍNDICE: n8n_chat_histories_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX n8n_chat_histories_pkey ON public.n8n_chat_histories USING btree (id)
3. ÍNDICES,TABELA: onboarding_data,ÍNDICE: onboarding_data_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX onboarding_data_pkey ON public.onboarding_data USING btree (id)
3. ÍNDICES,TABELA: plans,ÍNDICE: plans_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX plans_pkey ON public.plans USING btree (id)
3. ÍNDICES,TABELA: products,ÍNDICE: products_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX products_pkey ON public.products USING btree (id)
3. ÍNDICES,TABELA: terms_acceptances,ÍNDICE: terms_acceptances_pkey | DEFINIÇÃO: CREATE UNIQUE INDEX terms_acceptances_pkey ON public.terms_acceptances USING btree (id)
3. ÍNDICES,TABELA: users,ÍNDICE: users_pkey1 | DEFINIÇÃO: CREATE UNIQUE INDEX users_pkey1 ON public.users USING btree (id)
3. ÍNDICES,TABELA: users,ÍNDICE: users_email_key1 | DEFINIÇÃO: CREATE UNIQUE INDEX users_email_key1 ON public.users USING btree (email)
4. FUNÇÕES (RPC),FUNÇÃO: array_to_halfvec,"CREATE OR REPLACE FUNCTION public.array_to_halfvec(numeric[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_halfvec,"CREATE OR REPLACE FUNCTION public.array_to_halfvec(double precision[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_halfvec,"CREATE OR REPLACE FUNCTION public.array_to_halfvec(real[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_halfvec,"CREATE OR REPLACE FUNCTION public.array_to_halfvec(integer[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_sparsevec,"CREATE OR REPLACE FUNCTION public.array_to_sparsevec(real[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_sparsevec,"CREATE OR REPLACE FUNCTION public.array_to_sparsevec(double precision[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_sparsevec,"CREATE OR REPLACE FUNCTION public.array_to_sparsevec(numeric[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_sparsevec,"CREATE OR REPLACE FUNCTION public.array_to_sparsevec(integer[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_vector,"CREATE OR REPLACE FUNCTION public.array_to_vector(numeric[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_vector,"CREATE OR REPLACE FUNCTION public.array_to_vector(real[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_vector,"CREATE OR REPLACE FUNCTION public.array_to_vector(integer[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: array_to_vector,"CREATE OR REPLACE FUNCTION public.array_to_vector(double precision[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: binary_quantize,"CREATE OR REPLACE FUNCTION public.binary_quantize(vector)
 RETURNS bit
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$binary_quantize$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: binary_quantize,"CREATE OR REPLACE FUNCTION public.binary_quantize(halfvec)
 RETURNS bit
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_binary_quantize$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: cosine_distance,"CREATE OR REPLACE FUNCTION public.cosine_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_cosine_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: cosine_distance,"CREATE OR REPLACE FUNCTION public.cosine_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$cosine_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: cosine_distance,"CREATE OR REPLACE FUNCTION public.cosine_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_cosine_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: create_ingestion_job,"CREATE OR REPLACE FUNCTION public.create_ingestion_job()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  -- Insere uma nova linha diretamente na fila de tarefas.
  insert into public.ingestion_queue (company_id, file_path)
  values ((string_to_array(NEW.name, '/'))[1]::uuid, NEW.name);
  return NEW;
end;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: delete_document_vectors,"CREATE OR REPLACE FUNCTION public.delete_document_vectors()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Apaga os vetores correspondentes na tabela 'documents'
  delete from public.documents
  where metadata->>'source' = (string_to_array(old.name, '/'))[2];
  return old;
end;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: delete_document_vectors_on_storage_delete,"CREATE OR REPLACE FUNCTION public.delete_document_vectors_on_storage_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- A lógica agora é muito mais simples e direta:
  -- Apaga todas as linhas cujo 'file_path' seja igual ao caminho do ficheiro apagado.
  DELETE FROM public.documents
  WHERE file_path = old.name; -- 'old.name' é o caminho completo (ex: 'company_id/documento.pdf')

  RETURN OLD;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_affiliate_clients_details,"CREATE OR REPLACE FUNCTION public.get_affiliate_clients_details(p_affiliate_id uuid)
 RETURNS TABLE(user_id uuid, contact_name text, contact_email text, company_id uuid, company_name text, plan_id uuid, plan_name text, affiliate_id uuid, affiliate_name text, company_status text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        u.id AS user_id,
        u.full_name AS contact_name,
        u.email AS contact_email,
        c.id AS company_id,
        c.name AS company_name,
        c.plan_id,
        p.name AS plan_name,
        c.affiliate_id,
        a.name AS affiliate_name,
        c.status AS company_status
    FROM
        public.users u
        -- CORREÇÃO: Utiliza LEFT JOIN e COALESCE para garantir que os usuários sejam encontrados
        -- mesmo que a relação user -> company não esteja perfeitamente sincronizada,
        -- espelhando a lógica da função 'get_app_users_details' que já funciona.
        LEFT JOIN public.companies c ON c.id = COALESCE(u.company_id, u.id)
        LEFT JOIN public.plans p ON c.plan_id = p.id
        LEFT JOIN public.affiliates a ON c.affiliate_id = a.id
    WHERE
        -- A condição principal agora filtra corretamente os usuários que são 'app_user'
        -- E que pertencem a empresas associadas ao ID do afiliado fornecido.
        u.role = 'app_user' AND c.affiliate_id = p_affiliate_id;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_affiliate_dashboard_metrics,"CREATE OR REPLACE FUNCTION public.get_affiliate_dashboard_metrics(p_affiliate_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$DECLARE
    metrics JSON;
    v_total_revenue NUMERIC;
    v_total_clients INT;
    v_active_clients INT;
    v_commission_pending_month NUMERIC;
    v_commission_total_lifetime NUMERIC;
    v_new_clients_monthly_chart JSON;
    affiliate_rate NUMERIC;
BEGIN
    -- Obter a taxa de comissão do afiliado
    SELECT commission_rate INTO affiliate_rate
    FROM public.affiliates
    WHERE id = p_affiliate_id;

    IF NOT FOUND THEN
        -- Se não encontrar o afiliado, retorna vazio
        RETURN '{}'::json;
    END IF;

    -- 1. Receita (MRR) e Clientes ATIVOS (Contagem de EMPRESAS)
    SELECT
        COALESCE(SUM(CASE WHEN c.status = 'active' THEN p.price ELSE 0 END), 0),
        COUNT(CASE WHEN c.status = 'active' THEN 1 END)
    INTO
        v_total_revenue,
        v_active_clients
    FROM public.companies c
    LEFT JOIN public.plans p ON c.plan_id = p.id
    WHERE c.affiliate_id = p_affiliate_id;

    -- 1.5. Total de Clientes (Contagem de USUÁRIOS 'app_user')
    SELECT
        COUNT(u.id)
    INTO
        v_total_clients
    FROM public.users u
    JOIN public.companies c ON u.company_id = c.id
     WHERE c.affiliate_id = p_affiliate_id
      AND u.role = 'app_user';

    -- 2. Comissão Pendente (Mês Atual)
    v_commission_pending_month := v_total_revenue * affiliate_rate;

    -- 3. Comissão Total (Vitalícia) - (Placeholder)
    v_commission_total_lifetime := CASE WHEN v_total_clients > 0 THEN v_commission_pending_month * 12 ELSE 0 END;
    -- TODO: Substituir por um SUM de uma tabela 'affiliate_payments' quando existir.

    -- 4. Gráfico de Novos Clientes (EMPRESAS)
    SELECT json_agg(monthly_data)
    INTO v_new_clients_monthly_chart
    FROM (
        SELECT 
            to_char(date_trunc('month', created_at), 'YYYY-MM') AS month,
            COUNT(id) as count
        FROM public.companies
        WHERE affiliate_id = p_affiliate_id
          AND created_at >= date_trunc('month', now()) - interval '5 months'
        GROUP BY date_trunc('month', created_at)
        ORDER BY date_trunc('month', created_at)
    ) AS monthly_data;

    -- Compila o JSON final
    metrics := json_build_object(
        'total_revenue', v_total_revenue,
        'total_clients', v_total_clients,
        'active_clients', v_active_clients,
        'commission_pending_month', v_commission_pending_month,
        'commission_total_lifetime', v_commission_total_lifetime,
        'new_clients_monthly_chart', COALESCE(v_new_clients_monthly_chart, '[]'::json)
    );

    RETURN metrics;
END;$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_affiliate_metrics,"CREATE OR REPLACE FUNCTION public.get_affiliate_metrics(p_affiliate_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    metrics JSON;
    v_total_revenue NUMERIC;
    v_total_clients INT;
    v_active_clients INT;
    v_commission_pending_month NUMERIC;
    v_commission_total_lifetime NUMERIC;
    v_new_clients_monthly_chart JSON;
    affiliate_rate NUMERIC;
BEGIN
    -- Obter a taxa de comissão do afiliado
    SELECT commission_rate INTO affiliate_rate
    FROM public.affiliates
    WHERE id = p_affiliate_id;

    IF NOT FOUND THEN
        -- Se não encontrar o afiliado, retorna vazio
        RETURN '{}'::json;
    END IF;

    -- 1. Receita (MRR) e Clientes ATIVOS (Contagem de EMPRESAS)
    SELECT
        COALESCE(SUM(CASE WHEN c.status = 'active' THEN p.price ELSE 0 END), 0),
        COUNT(CASE WHEN c.status = 'active' THEN 1 END)
    INTO
        v_total_revenue,
        v_active_clients
    FROM public.companies c
    LEFT JOIN public.plans p ON c.plan_id = p.id
    WHERE c.affiliate_id = p_affiliate_id;

    -- 1.5. Total de Clientes (Contagem de USUÁRIOS 'app_user')
    SELECT
        COUNT(u.id)
    INTO
        v_total_clients
    FROM public.users u
    JOIN public.companies c ON u.company_id = c.id
    WHERE c.affiliate_id = p_affiliate_id
      AND u.role = 'app_user';

    -- 2. Comissão Pendente (Mês Atual)
    v_commission_pending_month := v_total_revenue * affiliate_rate;

    -- 3. Comissão Total (Vitalícia) - (Placeholder)
    v_commission_total_lifetime := CASE WHEN v_total_clients > 0 THEN v_commission_pending_month * 12 ELSE 0 END;
    -- TODO: Substituir por um SUM de uma tabela 'affiliate_payments' quando existir.

    -- 4. Gráfico de Novos Clientes (EMPRESAS)
    SELECT json_agg(monthly_data)
    INTO v_new_clients_monthly_chart
    FROM (
        SELECT 
            to_char(date_trunc('month', created_at), 'YYYY-MM') AS month,
            COUNT(id) as count
        FROM public.companies
        WHERE affiliate_id = p_affiliate_id
          AND created_at >= date_trunc('month', now()) - interval '5 months'
        GROUP BY date_trunc('month', created_at)
        ORDER BY date_trunc('month', created_at)
    ) AS monthly_data;

    -- Compila o JSON final
    metrics := json_build_object(
        'total_revenue', v_total_revenue,
        'total_clients', v_total_clients,
        'active_clients', v_active_clients,
        'commission_pending_month', v_commission_pending_month,
        'commission_total_lifetime', v_commission_total_lifetime,
        'new_clients_monthly_chart', COALESCE(v_new_clients_monthly_chart, '[]'::json)
    );

    RETURN metrics;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_affiliates_details,"CREATE OR REPLACE FUNCTION public.get_affiliates_details()
 RETURNS TABLE(affiliate_id uuid, affiliate_name text, login_email text, contact_email text, registration_date timestamp with time zone, commission_rate numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        a.id,
        a.name,
        u.email,
        a.contact_email,
        a.created_at,
        a.commission_rate
    FROM
        public.affiliates AS a
    LEFT JOIN
        public.users AS u ON a.id = u.id;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_app_users_details,"CREATE OR REPLACE FUNCTION public.get_app_users_details()
 RETURNS TABLE(user_id uuid, contact_name text, contact_email text, company_id uuid, company_name text, plan_id uuid, plan_name text, affiliate_id uuid, affiliate_name text, company_status text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        u.id AS user_id,
        u.full_name AS contact_name,
        u.email AS contact_email,
        c.id AS company_id,
        c.name AS company_name,
        c.plan_id,
        p.name AS plan_name,
        c.affiliate_id,
        a.name AS affiliate_name,
        c.status AS company_status
    FROM
        public.users u
        LEFT JOIN public.companies c ON c.id = COALESCE(u.company_id, u.id) -- Junção robusta
        LEFT JOIN public.plans p ON c.plan_id = p.id
        LEFT JOIN public.affiliates a ON c.affiliate_id = a.id
    WHERE
        u.role = 'app_user';
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_chat_history,"CREATE OR REPLACE FUNCTION public.get_chat_history(p_company_id uuid, p_customer_phone text)
 RETURNS TABLE(message_timestamp timestamp with time zone, sender text, message text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_session_id text;
BEGIN
    -- Constrói o session_id exatamente como no n8n (ex: ""company_id""_""17981112074"")
    -- (Baseado no seu ""Agente - Oreh.json"")
    v_session_id := p_company_id::text || '_' || p_customer_phone;

    RETURN QUERY
    SELECT
        v.created_at AS message_timestamp,
        v.sender,
        v.clean_message AS message
    FROM
        public.v_n8n_chat_histories_clean AS v -- Seleciona DIRETAMENTE da VIEW
    WHERE
        v.session_id = v_session_id
    ORDER BY
        v.created_at ASC;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_clients_details,"CREATE OR REPLACE FUNCTION public.get_clients_details()
 RETURNS TABLE(company_id uuid, contact_name text, company_name text, company_cnpj text, company_phone text, plan_name text, status text, affiliate_name text, plan_id uuid)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        c.id AS company_id,
        pu.full_name AS contact_name,
        c.name AS company_name,
        c.cnpj AS company_cnpj,
        c.phone AS company_phone,
        p.name AS plan_name,
        'Ativo' AS status, -- Placeholder, pode ser uma coluna real no futuro
        a.name AS affiliate_name,
        c.plan_id
    FROM
        public.companies c
        LEFT JOIN public.plans p ON c.plan_id = p.id
        LEFT JOIN public.affiliates a ON c.affiliate_id = a.id
        -- Apenas o primeiro usuário da empresa é considerado o contato principal
        LEFT JOIN (
            SELECT DISTINCT ON (company_id) * FROM public.users
        ) pu ON c.id = pu.company_id;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_dashboard_metrics,"CREATE OR REPLACE FUNCTION public.get_dashboard_metrics()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    result json;
    logged_in_company_id uuid;
    v_chat_count INT;
    v_chat_limit INT;
BEGIN
    -- 1. Obter o company_id do usuário autenticado
    SELECT company_id INTO logged_in_company_id
    FROM public.users
    WHERE id = auth.uid();

    IF logged_in_company_id IS NULL THEN
        RETURN '{}'::json;
    END IF;

    -- 2. Buscar métricas principais
    WITH 
    chats_mes_corrente AS (
        SELECT *
        FROM public.chats
        WHERE company_id = logged_in_company_id
          AND created_at >= date_trunc('month', current_date)
          AND created_at < date_trunc('month', current_date) + interval '1 month'
          AND (temperatura <> 'DESCARTE' OR temperatura IS NULL) 
    ),
    
    volume_diario AS (
        SELECT
            (current_date - g.day) AS day,
            COUNT(c.id) AS count
        FROM generate_series(0, 6) AS g(day)
        LEFT JOIN public.chats c ON 
            date_trunc('day', c.created_at) = (current_date - g.day) 
            AND c.company_id = logged_in_company_id
            AND (c.temperatura <> 'DESCARTE' OR c.temperatura IS NULL)
        GROUP BY 1
        ORDER BY 1
    ),

    -- NOVO: Buscar o limite do plano e a contagem de chats
    plan_data AS (
        SELECT 
            p.monthly_chat_limit,
            (SELECT COUNT(*) FROM chats_mes_corrente) as chat_count
        FROM public.companies c
        LEFT JOIN public.plans p ON c.plan_id = p.id
        WHERE c.id = logged_in_company_id
    )

    -- 3. Monta o objeto JSON final
    SELECT
        json_build_object(
            -- Métrica antiga mantida
            'total_atendimentos_mes', (SELECT COUNT(*) FROM chats_mes_corrente),

            -- Campos antigos removidos (resolvidos_ia_percent, leads_qualificados)
            
            -- NOVOS CAMPOS ADICIONADOS
            'chat_count_month', (SELECT chat_count FROM plan_data),
            'chat_limit_plan', (SELECT monthly_chat_limit FROM plan_data),

            -- Gráficos (mantidos)
            'funil_data', json_build_object(
                'topo', (SELECT COUNT(*) FROM chats_mes_corrente WHERE temperatura = 'Novo'),
                'meio', (SELECT COUNT(*) FROM chats_mes_corrente WHERE temperatura = 'Atendimento'),
                'fundo', (SELECT COUNT(*) FROM chats_mes_corrente WHERE temperatura = 'Agendado')
            ),
            'volume_ultimos_7_dias', (SELECT json_agg(vd) FROM volume_diario vd),
            'new_clients_month', (
                SELECT COUNT(*) 
                FROM public.clients 
                WHERE company_id = logged_in_company_id 
                  AND created_at >= date_trunc('month', current_date)
            )
        )
    INTO result;

    RETURN result;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_my_company_id,"CREATE OR REPLACE FUNCTION public.get_my_company_id()
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$BEGIN
  RETURN (SELECT company_id FROM public.users WHERE id = auth.uid());
END;$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_new_clients_monthly,"CREATE OR REPLACE FUNCTION public.get_new_clients_monthly()
 RETURNS TABLE(month text, count bigint)
 LANGUAGE plpgsql
AS $function$
  BEGIN
    RETURN QUERY
    SELECT 
      to_char(date_trunc('month', created_at), 'YYYY-MM') AS month,
      COUNT(id) as count
    FROM 
      public.companies
    WHERE 
      created_at >= date_trunc('month', now()) - interval '5 months'
    GROUP BY 
      date_trunc('month', created_at)
    ORDER BY 
      date_trunc('month', created_at);
  END;
  $function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_super_admin_metrics,"CREATE OR REPLACE FUNCTION public.get_super_admin_metrics()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    total_affiliates INT;
    total_clients INT;
    total_revenue NUMERIC;
BEGIN
    SELECT COUNT(*) INTO total_affiliates FROM affiliates;
    SELECT COUNT(*) INTO total_clients FROM companies;
    SELECT COALESCE(SUM(p.price), 0) INTO total_revenue 
    FROM companies c
    JOIN plans p ON c.plan_id = p.id
    WHERE c.status = 'active';

    RETURN json_build_object(
        'total_affiliates', total_affiliates,
        'total_clients', total_clients,
        'total_revenue', total_revenue
    );
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: get_superadmin_dashboard_metrics,"CREATE OR REPLACE FUNCTION public.get_superadmin_dashboard_metrics()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    metrics JSON;
    v_total_revenue NUMERIC;
    v_total_clients INT;
    v_total_affiliates INT;
    v_clients_by_status JSON;
    v_commissions_to_pay_month NUMERIC;
    v_avg_ticket NUMERIC;
    v_churn_rate_month NUMERIC;
    v_clients_by_affiliate JSON;
    v_commissions_by_affiliate JSON;
    v_new_clients_monthly JSON;
BEGIN
    -- 1. Métricas de Receita e Ticket Médio (CLIENTES ATIVOS - ***ALTERADO***)
    -- Baseado em EMPRESAS ATIVAS que possuem pelo menos um 'app_user'
    SELECT
        COALESCE(SUM(p.price), 0),
        COALESCE(SUM(p.price) / NULLIF(COUNT(DISTINCT c.id), 0), 0)
    INTO
        v_total_revenue,
        v_avg_ticket
    FROM public.companies c
    JOIN public.plans p ON c.plan_id = p.id
    WHERE c.status = 'active'
      AND EXISTS ( -- Garante que a empresa tenha pelo menos um usuário 'app_user'
          SELECT 1
          FROM public.users u
          WHERE u.company_id = c.id
            AND u.role = 'app_user'
      );

    -- 1b. Total de Clientes (GERAL - Contagem de USUÁRIOS 'app_user')
    SELECT COUNT(id)
    INTO v_total_clients
    FROM public.users
    WHERE role = 'app_user';

    -- 2. Total de Afiliados (Contagem de AFILIADOS)
    SELECT COUNT(*)
    INTO v_total_affiliates
    FROM public.affiliates;

    -- 3. Clientes por Status (***CORRIGIDO***)
    -- Baseado em USUÁRIOS 'app_user', agrupados pelo status da EMPRESA
    -- Correção: A agregação 'json_object_agg' foi movida para fora de uma subconsulta
    -- para evitar o erro 'aggregate function calls cannot be nested'.
    SELECT json_object_agg(status, count)
    INTO v_clients_by_status
    FROM (
        SELECT 
            COALESCE(c.status, 'unknown') AS status, 
            COUNT(u.id) AS count
        FROM public.users u
        LEFT JOIN public.companies c ON u.company_id = c.id
        WHERE u.role = 'app_user'
        GROUP BY c.status
    ) AS status_counts;

    -- 4. Comissões a Pagar no Mês Atual (***ALTERADO***)
    -- Baseado em EMPRESAS ATIVAS que possuem 'app_user'
    SELECT COALESCE(SUM(p.price * a.commission_rate), 0)
    INTO v_commissions_to_pay_month
    FROM public.companies c
    JOIN public.plans p ON c.plan_id = p.id
    JOIN public.affiliates a ON c.affiliate_id = a.id
    WHERE c.status = 'active'
      AND c.created_at <= now()
      AND EXISTS ( -- Garante que a empresa tenha pelo menos um usuário 'app_user'
          SELECT 1
          FROM public.users u
          WHERE u.company_id = c.id
            AND u.role = 'app_user'
      );

    -- 5. Churn Rate (Placeholder)
    SELECT 0.0
    INTO v_churn_rate_month;

    -- 6. Clientes por Afiliado (***ALTERADO***)
    -- Baseado em USUÁRIOS 'app_user'
    SELECT json_agg(affiliate_counts)
    INTO v_clients_by_affiliate
    FROM (
        SELECT 
            COALESCE(a.name, 'Sem Afiliado') AS name,
            COUNT(u.id) AS count -- Conta usuários
        FROM public.users u
        LEFT JOIN public.companies c ON u.company_id = c.id -- Junta com companies para pegar o affiliate_id
        LEFT JOIN public.affiliates a ON c.affiliate_id = a.id
        WHERE u.role = 'app_user' -- Filtra por app_user
        GROUP BY a.name
    ) AS affiliate_counts;

    -- 7. Comissões por Afiliado (Mês Atual) (***ALTERADO***)
    -- Baseado em EMPRESAS ATIVAS que possuem 'app_user'
    SELECT json_agg(commission_totals)
    INTO v_commissions_by_affiliate
    FROM (
        SELECT 
            a.name,
            COALESCE(SUM(p.price * a.commission_rate), 0) AS total
        FROM public.companies c
        JOIN public.plans p ON c.plan_id = p.id
        JOIN public.affiliates a ON c.affiliate_id = a.id
        WHERE c.status = 'active'
          AND EXISTS ( -- Garante que a empresa tenha pelo menos um usuário 'app_user'
              SELECT 1
              FROM public.users u
              WHERE u.company_id = c.id
                AND u.role = 'app_user'
          )
        GROUP BY a.name
        HAVING COALESCE(SUM(p.price * a.commission_rate), 0) > 0
    ) AS commission_totals;

    -- 8. Novos Clientes por Mês (Plataforma - ***ALTERADO***)
    -- Baseado em USUÁRIOS 'app_user'
    SELECT json_agg(monthly_data)
    INTO v_new_clients_monthly
    FROM (
        SELECT 
            to_char(date_trunc('month', created_at), 'YYYY-MM') AS month,
            COUNT(id) as count
        FROM public.users -- Alterado de companies para users
        WHERE role = 'app_user' -- Filtra por app_user
          AND created_at >= date_trunc('month', now()) - interval '5 months'
        GROUP BY date_trunc('month', created_at)
        ORDER BY date_trunc('month', created_at)
    ) AS monthly_data;


    -- Compila o JSON final
    metrics := json_build_object(
        'total_revenue', v_total_revenue,
        'total_clients', v_total_clients,
        'total_affiliates', v_total_affiliates,
        'clients_by_status', COALESCE(v_clients_by_status, '{}'::json),
        'commissions_to_pay_month', v_commissions_to_pay_month,
        'avg_ticket', v_avg_ticket,
        'churn_rate_month', v_churn_rate_month,
        'clients_by_affiliate', COALESCE(v_clients_by_affiliate, '[]'::json),
        'commissions_by_affiliate', COALESCE(v_commissions_by_affiliate, '[]'::json),
        'new_clients_monthly', COALESCE(v_new_clients_monthly, '[]'::json)
    );

    RETURN metrics;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec,"CREATE OR REPLACE FUNCTION public.halfvec(halfvec, integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_accum,"CREATE OR REPLACE FUNCTION public.halfvec_accum(double precision[], halfvec)
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_accum$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_add,"CREATE OR REPLACE FUNCTION public.halfvec_add(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_add$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_avg,"CREATE OR REPLACE FUNCTION public.halfvec_avg(double precision[])
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_avg$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_cmp,"CREATE OR REPLACE FUNCTION public.halfvec_cmp(halfvec, halfvec)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_cmp$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_combine,"CREATE OR REPLACE FUNCTION public.halfvec_combine(double precision[], double precision[])
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_combine$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_concat,"CREATE OR REPLACE FUNCTION public.halfvec_concat(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_concat$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_eq,"CREATE OR REPLACE FUNCTION public.halfvec_eq(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_eq$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_ge,"CREATE OR REPLACE FUNCTION public.halfvec_ge(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_ge$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_gt,"CREATE OR REPLACE FUNCTION public.halfvec_gt(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_gt$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_in,"CREATE OR REPLACE FUNCTION public.halfvec_in(cstring, oid, integer)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_in$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_l2_squared_distance,"CREATE OR REPLACE FUNCTION public.halfvec_l2_squared_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_squared_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_le,"CREATE OR REPLACE FUNCTION public.halfvec_le(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_le$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_lt,"CREATE OR REPLACE FUNCTION public.halfvec_lt(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_lt$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_mul,"CREATE OR REPLACE FUNCTION public.halfvec_mul(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_mul$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_ne,"CREATE OR REPLACE FUNCTION public.halfvec_ne(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_ne$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_negative_inner_product,"CREATE OR REPLACE FUNCTION public.halfvec_negative_inner_product(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_negative_inner_product$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_out,"CREATE OR REPLACE FUNCTION public.halfvec_out(halfvec)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_out$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_recv,"CREATE OR REPLACE FUNCTION public.halfvec_recv(internal, oid, integer)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_recv$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_send,"CREATE OR REPLACE FUNCTION public.halfvec_send(halfvec)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_send$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_spherical_distance,"CREATE OR REPLACE FUNCTION public.halfvec_spherical_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_spherical_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_sub,"CREATE OR REPLACE FUNCTION public.halfvec_sub(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_sub$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_to_float4,"CREATE OR REPLACE FUNCTION public.halfvec_to_float4(halfvec, integer, boolean)
 RETURNS real[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_to_float4$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_to_sparsevec,"CREATE OR REPLACE FUNCTION public.halfvec_to_sparsevec(halfvec, integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_to_sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_to_vector,"CREATE OR REPLACE FUNCTION public.halfvec_to_vector(halfvec, integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_to_vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: halfvec_typmod_in,"CREATE OR REPLACE FUNCTION public.halfvec_typmod_in(cstring[])
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_typmod_in$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: hamming_distance,"CREATE OR REPLACE FUNCTION public.hamming_distance(bit, bit)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$hamming_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: handle_new_user,"CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$BEGIN
  -- 1. Cria a nova empresa, usando o ID do usuário como ID da empresa e populando com os dados do cadastro.
  INSERT INTO public.companies (
    id, 
    name,                               -- Nome da empresa será o nome completo do usuário
    cnpj,                               -- Documento do usuário
    asaas_customer_id                   -- ID do cliente Asaas
  )
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'cpf_cnpj',
    new.raw_user_meta_data->>'asaas_customer_id'
  );

  -- 2. Cria os registros de segredos para a nova empresa.
  INSERT INTO public.company_secrets (company_id)
  VALUES (new.id);

  -- 3. Insere o registro na tabela public.users, agora incluindo o nome completo e o company_id.
  INSERT INTO public.users (
    id, 
    email, 
    company_id,
    full_name                           -- Nome completo do usuário
  )
  VALUES (
    new.id, 
    new.email, 
    new.id,
    new.raw_user_meta_data->>'full_name'
  );
  
  RETURN new;
END;$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: hnsw_bit_support,"CREATE OR REPLACE FUNCTION public.hnsw_bit_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$hnsw_bit_support$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: hnsw_halfvec_support,"CREATE OR REPLACE FUNCTION public.hnsw_halfvec_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$hnsw_halfvec_support$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: hnsw_sparsevec_support,"CREATE OR REPLACE FUNCTION public.hnsw_sparsevec_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$hnsw_sparsevec_support$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: hnswhandler,"CREATE OR REPLACE FUNCTION public.hnswhandler(internal)
 RETURNS index_am_handler
 LANGUAGE c
AS '$libdir/vector', $function$hnswhandler$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: increment_coupon_usage,"CREATE OR REPLACE FUNCTION public.increment_coupon_usage(p_coupon_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    UPDATE public.coupons
    SET usage_count = usage_count + 1
    WHERE id = p_coupon_id;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: inner_product,"CREATE OR REPLACE FUNCTION public.inner_product(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_inner_product$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: inner_product,"CREATE OR REPLACE FUNCTION public.inner_product(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$inner_product$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: inner_product,"CREATE OR REPLACE FUNCTION public.inner_product(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_inner_product$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: ivfflat_bit_support,"CREATE OR REPLACE FUNCTION public.ivfflat_bit_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$ivfflat_bit_support$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: ivfflat_halfvec_support,"CREATE OR REPLACE FUNCTION public.ivfflat_halfvec_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$ivfflat_halfvec_support$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: ivfflathandler,"CREATE OR REPLACE FUNCTION public.ivfflathandler(internal)
 RETURNS index_am_handler
 LANGUAGE c
AS '$libdir/vector', $function$ivfflathandler$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: jaccard_distance,"CREATE OR REPLACE FUNCTION public.jaccard_distance(bit, bit)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$jaccard_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l1_distance,"CREATE OR REPLACE FUNCTION public.l1_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$l1_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l1_distance,"CREATE OR REPLACE FUNCTION public.l1_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l1_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l1_distance,"CREATE OR REPLACE FUNCTION public.l1_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l1_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_distance,"CREATE OR REPLACE FUNCTION public.l2_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$l2_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_distance,"CREATE OR REPLACE FUNCTION public.l2_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_distance,"CREATE OR REPLACE FUNCTION public.l2_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_norm,"CREATE OR REPLACE FUNCTION public.l2_norm(halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_norm$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_norm,"CREATE OR REPLACE FUNCTION public.l2_norm(sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_norm$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_normalize,"CREATE OR REPLACE FUNCTION public.l2_normalize(halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_normalize$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_normalize,"CREATE OR REPLACE FUNCTION public.l2_normalize(vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$l2_normalize$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: l2_normalize,"CREATE OR REPLACE FUNCTION public.l2_normalize(sparsevec)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_normalize$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: login,"CREATE OR REPLACE FUNCTION public.login(email_param text, password_param text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    user_record public.users;
    result json;
BEGIN
    SELECT * INTO user_record
    FROM public.users
    WHERE email = email_param;

    IF NOT FOUND THEN
        RETURN json_build_object('status', 404, 'message', 'Usuário não encontrado');
    END IF;

    -- A função crypt() compara a senha enviada com o hash salvo
    IF user_record.password_hash = crypt(password_param, user_record.password_hash) THEN
        result := json_build_object(
            'status', 200,
            'message', 'Login bem-sucedido',
            'payload', json_build_object(
                'userId', user_record.id,
                'companyId', user_record.company_id,
                'role', user_record.role,
                'fullName', user_record.full_name
            )
        );
        RETURN result;
    ELSE
        RETURN json_build_object('status', 401, 'message', 'Senha inválida');
    END IF;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: match_documents,"CREATE OR REPLACE FUNCTION public.match_documents(query_embedding vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb)
 RETURNS TABLE(id bigint, content text, metadata jsonb, similarity double precision)
 LANGUAGE plpgsql
AS $function$
#variable_conflict use_column
begin
  return query
  select
    id,
    content,
    metadata,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  where metadata @> filter
  order by documents.embedding <=> query_embedding
  limit match_count;
end;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: safe_parse_ai_message,"CREATE OR REPLACE FUNCTION public.safe_parse_ai_message(raw_content text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    cleaned_content text;
    temp_jsonb jsonb;
    final_message text;
BEGIN
    -- 1. Limpa os code fences (```) e espaços em branco das pontas
    cleaned_content := TRIM(BOTH E' \n\`' FROM 
        regexp_replace(raw_content, E'```json\\n?(.+?)\\n?```$', E'\\1', 's')
    );

    -- 2. Bloco de extração segura
    BEGIN
        -- 2a. Tenta converter o texto JÁ LIMPO para JSONB.
        -- Se cleaned_content = '{""messages"":...}' -> temp_jsonb = {""messages"":...} (jsonb)
        -- Se cleaned_content = '""{\""messages\"":...}""' -> temp_jsonb = ""{\""messages\"":...}"" (jsonb string)
        temp_jsonb := cleaned_content::jsonb;

        -- 2b. VERIFICAÇÃO PRINCIPAL:
        -- Se o resultado for um TIPO 'string' (o nosso caso de JSON escapado)
        IF jsonb_typeof(temp_jsonb) = 'string' THEN
            -- Desempacota (extrai o texto) e converte NOVAMENTE.
            temp_jsonb := (temp_jsonb #>> '{}')::jsonb;
        END IF;

        -- 2c. Agora temp_jsonb é um objeto. Extrai as mensagens.
        SELECT string_agg(elem::text, E'\n')
        INTO final_message
        FROM jsonb_array_elements_text(temp_jsonb -> 'messages');
        
    EXCEPTION
        -- Se qualquer etapa acima falhar (cast, chave 'messages' não existe, etc.)
        WHEN others THEN
            final_message := NULL;
    END;

    -- 3. Retorna a mensagem extraída (se sucesso) ou o texto limpo (se falha)
    --    Usamos cleaned_content como fallback, não raw_content, para pelo menos remover os fences.
    RETURN COALESCE(final_message, cleaned_content);
    
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: set_affiliate_role,"CREATE OR REPLACE FUNCTION public.set_affiliate_role()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Esta função é acionada por um trigger 'AFTER INSERT' na tabela 'affiliates'.
  -- 'NEW.id' contém o ID do novo afiliado que foi inserido, que corresponde ao 'user.id'.

  -- Atualiza a coluna 'role' na tabela 'users' para 'admin'
  -- para o usuário cujo ID corresponde ao do novo afiliado.
  UPDATE public.users
  SET role = 'admin'
  WHERE id = NEW.id;

  -- Retorna NEW, que é a prática padrão para triggers de INSERT/UPDATE.
  RETURN NEW;
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec,"CREATE OR REPLACE FUNCTION public.sparsevec(sparsevec, integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_cmp,"CREATE OR REPLACE FUNCTION public.sparsevec_cmp(sparsevec, sparsevec)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_cmp$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_eq,"CREATE OR REPLACE FUNCTION public.sparsevec_eq(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_eq$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_ge,"CREATE OR REPLACE FUNCTION public.sparsevec_ge(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_ge$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_gt,"CREATE OR REPLACE FUNCTION public.sparsevec_gt(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_gt$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_in,"CREATE OR REPLACE FUNCTION public.sparsevec_in(cstring, oid, integer)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_in$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_l2_squared_distance,"CREATE OR REPLACE FUNCTION public.sparsevec_l2_squared_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_squared_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_le,"CREATE OR REPLACE FUNCTION public.sparsevec_le(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_le$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_lt,"CREATE OR REPLACE FUNCTION public.sparsevec_lt(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_lt$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_ne,"CREATE OR REPLACE FUNCTION public.sparsevec_ne(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_ne$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_negative_inner_product,"CREATE OR REPLACE FUNCTION public.sparsevec_negative_inner_product(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_negative_inner_product$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_out,"CREATE OR REPLACE FUNCTION public.sparsevec_out(sparsevec)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_out$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_recv,"CREATE OR REPLACE FUNCTION public.sparsevec_recv(internal, oid, integer)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_recv$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_send,"CREATE OR REPLACE FUNCTION public.sparsevec_send(sparsevec)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_send$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_to_halfvec,"CREATE OR REPLACE FUNCTION public.sparsevec_to_halfvec(sparsevec, integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_to_halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_to_vector,"CREATE OR REPLACE FUNCTION public.sparsevec_to_vector(sparsevec, integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_to_vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sparsevec_typmod_in,"CREATE OR REPLACE FUNCTION public.sparsevec_typmod_in(cstring[])
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_typmod_in$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: subvector,"CREATE OR REPLACE FUNCTION public.subvector(vector, integer, integer)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$subvector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: subvector,"CREATE OR REPLACE FUNCTION public.subvector(halfvec, integer, integer)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_subvector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: sync_company_user_details,"CREATE OR REPLACE FUNCTION public.sync_company_user_details()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    company_record RECORD;
    user_record RECORD;
    plan_record RECORD;
    affiliate_record RECORD;
    v_company_id uuid;
BEGIN
    -- Determina o company_id relevante baseado na tabela que acionou o trigger
    IF TG_TABLE_NAME = 'companies' THEN
        v_company_id := COALESCE(NEW.id, OLD.id);
    ELSIF TG_TABLE_NAME = 'users' THEN
        v_company_id := COALESCE(NEW.company_id, OLD.company_id);
    ELSIF TG_TABLE_NAME = 'plans' THEN
        -- Se um plano muda, precisamos atualizar TODAS as empresas que usam esse plano
        -- Atualizar todos individualmente pode ser pesado. Uma abordagem mais simples é apenas buscar o company_id se existir.
        -- Uma abordagem mais robusta seria atualizar em lote, mas vamos manter simples por agora.
        SELECT id INTO v_company_id FROM public.companies WHERE plan_id = COALESCE(NEW.id, OLD.id) LIMIT 1;
    ELSIF TG_TABLE_NAME = 'affiliates' THEN
        -- Se um afiliado muda, precisamos atualizar TODAS as empresas ligadas a ele
        SELECT id INTO v_company_id FROM public.companies WHERE affiliate_id = COALESCE(NEW.id, OLD.id) LIMIT 1;
    END IF;

    -- Se não encontrarmos um company_id relevante, saímos (ex: usuário sem empresa)
    IF v_company_id IS NULL THEN
        -- Se for DELETE em companies, remove da tabela sync
        IF TG_OP = 'DELETE' AND TG_TABLE_NAME = 'companies' THEN
             DELETE FROM public.company_user_details_sync WHERE company_id = OLD.id;
        END IF;
        RETURN NULL; -- Importante retornar NULL para triggers AFTER
    END IF;

    -- Se for uma operação DELETE na tabela companies
    IF TG_OP = 'DELETE' AND TG_TABLE_NAME = 'companies' THEN
        DELETE FROM public.company_user_details_sync WHERE company_id = OLD.id;
        RETURN OLD;
    END IF;

    -- Busca os dados mais recentes das tabelas relacionadas
    SELECT * INTO company_record FROM public.companies WHERE id = v_company_id;
    -- Considera apenas o primeiro usuário associado, ou o usuário que mudou, como contato principal
    SELECT * INTO user_record FROM public.users WHERE company_id = v_company_id ORDER BY created_at LIMIT 1;
    SELECT * INTO plan_record FROM public.plans WHERE id = company_record.plan_id;
    SELECT * INTO affiliate_record FROM public.affiliates WHERE id = company_record.affiliate_id;

    -- Insere ou Atualiza a linha na tabela sincronizada
    INSERT INTO public.company_user_details_sync (
        company_id, company_name, official_name, company_status, plan_id, affiliate_id, company_created_at,
        user_id, contact_name, contact_email, user_role, plan_name, affiliate_name, last_synced_at
    ) VALUES (
        company_record.id, company_record.name, company_record.official_name, company_record.status, company_record.plan_id, company_record.affiliate_id, company_record.created_at,
        user_record.id, user_record.full_name, user_record.email, user_record.role, plan_record.name, affiliate_record.name, now()
    )
    ON CONFLICT (company_id) DO UPDATE SET
        company_name = EXCLUDED.company_name,
        official_name = EXCLUDED.official_name,
        company_status = EXCLUDED.company_status,
        plan_id = EXCLUDED.plan_id,
        affiliate_id = EXCLUDED.affiliate_id,
        company_created_at = EXCLUDED.company_created_at, -- Pode não ser necessário atualizar
        user_id = EXCLUDED.user_id,
        contact_name = EXCLUDED.contact_name,
        contact_email = EXCLUDED.contact_email,
        user_role = EXCLUDED.user_role,
        plan_name = EXCLUDED.plan_name,
        affiliate_name = EXCLUDED.affiliate_name,
        last_synced_at = now();

    RETURN NULL; -- Triggers AFTER devem retornar NULL
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: update_company_details_as_admin,"CREATE OR REPLACE FUNCTION public.update_company_details_as_admin(p_company_id uuid, p_user_id uuid, p_contact_name text, p_plan_id uuid, p_affiliate_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Primeiro, garante que a empresa existe. Se não, cria-a usando o user_id como company_id.
    INSERT INTO public.companies (id, name)
    VALUES (p_company_id, p_contact_name)
    ON CONFLICT (id) DO NOTHING;

    -- Depois, atualiza a empresa com o novo plano e afiliado.
    -- Esta atualização será bem-sucedida porque a função é executada com as permissões do definidor.
    UPDATE public.companies
    SET 
        plan_id = p_plan_id,
        affiliate_id = p_affiliate_id,
        name = p_contact_name -- Também atualiza o nome, para o caso de
    WHERE id = p_company_id;
    
    -- Finalmente, garante que o utilizador está ligado à empresa.
    UPDATE public.users
    SET company_id = p_company_id
    WHERE id = p_user_id AND company_id IS NULL;

END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: update_overdue_accounts,"CREATE OR REPLACE FUNCTION public.update_overdue_accounts()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE public.companies
    SET status = 'overdue'
    WHERE 
        status = 'payment_pending' 
        AND created_at < (NOW() - INTERVAL '7 days')
        
        -- ADICIONADO:
        -- Verifica se o 'id' da empresa que está sendo atualizada
        -- (public.companies.id) NÃO EXISTE na tabela 'public.affiliates'.
        -- Se o ID existir lá (ou seja, a empresa É uma afiliada), 
        -- a condição falha e a linha é ignorada.
        AND NOT EXISTS (
            SELECT 1 
            FROM public.affiliates a
            WHERE a.id = public.companies.id
        );
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: validate_coupon,"CREATE OR REPLACE FUNCTION public.validate_coupon(coupon_code text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    coupon_record record;
BEGIN
    -- Busca o cupom pelo código, ignorando maiúsculas/minúsculas
    SELECT * INTO coupon_record
    FROM public.coupons
    WHERE upper(code) = upper(coupon_code);

    IF NOT FOUND THEN
        RETURN json_build_object('error', 'Cupom não encontrado.');
    END IF;

    IF NOT coupon_record.is_active THEN
        RETURN json_build_object('error', 'Este cupom não está mais ativo.');
    END IF;

    IF coupon_record.expires_at IS NOT NULL AND coupon_record.expires_at < now() THEN
        RETURN json_build_object('error', 'Este cupom expirou.');
    END IF;

    IF coupon_record.usage_limit IS NOT NULL AND coupon_record.usage_count >= coupon_record.usage_limit THEN
        RETURN json_build_object('error', 'Este cupom atingiu o limite de usos.');
    END IF;

    -- Se todas as validações passaram, retorna os dados do cupom
    RETURN json_build_object(
        'id', coupon_record.id,
        'code', coupon_record.code,
        'discount_type', coupon_record.discount_type,
        'discount_value', coupon_record.discount_value,
        'applicable_plan_id', coupon_record.applicable_plan_id
    );
END;
$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector,"CREATE OR REPLACE FUNCTION public.vector(vector, integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_accum,"CREATE OR REPLACE FUNCTION public.vector_accum(double precision[], vector)
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_accum$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_add,"CREATE OR REPLACE FUNCTION public.vector_add(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_add$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_avg,"CREATE OR REPLACE FUNCTION public.vector_avg(double precision[])
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_avg$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_cmp,"CREATE OR REPLACE FUNCTION public.vector_cmp(vector, vector)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_cmp$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_combine,"CREATE OR REPLACE FUNCTION public.vector_combine(double precision[], double precision[])
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_combine$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_concat,"CREATE OR REPLACE FUNCTION public.vector_concat(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_concat$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_dims,"CREATE OR REPLACE FUNCTION public.vector_dims(halfvec)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_vector_dims$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_dims,"CREATE OR REPLACE FUNCTION public.vector_dims(vector)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_dims$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_eq,"CREATE OR REPLACE FUNCTION public.vector_eq(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_eq$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_ge,"CREATE OR REPLACE FUNCTION public.vector_ge(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_ge$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_gt,"CREATE OR REPLACE FUNCTION public.vector_gt(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_gt$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_in,"CREATE OR REPLACE FUNCTION public.vector_in(cstring, oid, integer)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_in$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_l2_squared_distance,"CREATE OR REPLACE FUNCTION public.vector_l2_squared_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_l2_squared_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_le,"CREATE OR REPLACE FUNCTION public.vector_le(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_le$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_lt,"CREATE OR REPLACE FUNCTION public.vector_lt(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_lt$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_mul,"CREATE OR REPLACE FUNCTION public.vector_mul(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_mul$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_ne,"CREATE OR REPLACE FUNCTION public.vector_ne(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_ne$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_negative_inner_product,"CREATE OR REPLACE FUNCTION public.vector_negative_inner_product(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_negative_inner_product$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_norm,"CREATE OR REPLACE FUNCTION public.vector_norm(vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_norm$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_out,"CREATE OR REPLACE FUNCTION public.vector_out(vector)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_out$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_recv,"CREATE OR REPLACE FUNCTION public.vector_recv(internal, oid, integer)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_recv$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_send,"CREATE OR REPLACE FUNCTION public.vector_send(vector)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_send$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_spherical_distance,"CREATE OR REPLACE FUNCTION public.vector_spherical_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_spherical_distance$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_sub,"CREATE OR REPLACE FUNCTION public.vector_sub(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_sub$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_to_float4,"CREATE OR REPLACE FUNCTION public.vector_to_float4(vector, integer, boolean)
 RETURNS real[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_to_float4$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_to_halfvec,"CREATE OR REPLACE FUNCTION public.vector_to_halfvec(vector, integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_to_halfvec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_to_sparsevec,"CREATE OR REPLACE FUNCTION public.vector_to_sparsevec(vector, integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_to_sparsevec$function$
"
4. FUNÇÕES (RPC),FUNÇÃO: vector_typmod_in,"CREATE OR REPLACE FUNCTION public.vector_typmod_in(cstring[])
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_typmod_in$function$
"
5. GATILHOS (TRIGGERS),TABELA: affiliates,GATILHO: trigger_sync_after_affiliate_change | EVENTO: UPDATE | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
5. GATILHOS (TRIGGERS),TABELA: affiliates,GATILHO: on_affiliate_insert_set_role | EVENTO: INSERT | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION set_affiliate_role()
5. GATILHOS (TRIGGERS),TABELA: companies,GATILHO: trigger_sync_after_company_change | EVENTO: INSERT | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
5. GATILHOS (TRIGGERS),TABELA: companies,GATILHO: trigger_sync_after_company_change | EVENTO: DELETE | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
5. GATILHOS (TRIGGERS),TABELA: companies,GATILHO: trigger_sync_after_company_change | EVENTO: UPDATE | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
5. GATILHOS (TRIGGERS),TABELA: plans,GATILHO: trigger_sync_after_plan_change | EVENTO: UPDATE | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
5. GATILHOS (TRIGGERS),TABELA: users,GATILHO: trigger_sync_after_user_change | EVENTO: UPDATE | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
5. GATILHOS (TRIGGERS),TABELA: users,GATILHO: trigger_sync_after_user_change | EVENTO: INSERT | QUANDO: AFTER | EXECUTA: EXECUTE FUNCTION sync_company_user_details()
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliate_legal_documents,"POLÍTICA: Allow super_admins to manage affiliate documents | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliate_legal_documents,POLÍTICA: Allow public read access for affiliates | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): true | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,POLÍTICA: Allow affiliates to view their own data | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (auth.uid() = id) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,"POLÍTICA: Allow admins to read affiliates | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = ANY (ARRAY['super_admin'::text, 'admin'::text])) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,"POLÍTICA: Allow super_admins to insert affiliates | COMANDO: INSERT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): N/A | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,"POLÍTICA: Allow super_admins to update affiliates | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,POLÍTICA: Allow new users to create their own affiliate profile | COMANDO: INSERT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): N/A | VERIFICANDO (WITH CHECK): (auth.uid() = id)
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,"POLÍTICA: Allow admins to view all affiliates | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = ANY (ARRAY['admin'::text, 'super_admin'::text])) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,"POLÍTICA: Allow super_admins to update affiliate data | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: affiliates,"POLÍTICA: Allow super_admins to delete affiliates | COMANDO: DELETE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: ai_token_usage,POLÍTICA: Usuários podem ver e criar logs de uso da sua própria empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = get_my_company_id()) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: app_logs,"POLÍTICA: Allow users to read their own company logs | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())) = company_id) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: app_logs,POLÍTICA: Allow authenticated users to insert logs | COMANDO: INSERT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): N/A | VERIFICANDO (WITH CHECK): (auth.uid() = user_id)
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: chats,POLÍTICA: Permitir acesso total aos chats da própria empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = get_my_company_id()) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: clients,"POLÍTICA: Usuários podem gerir clientes da própria empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())))"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: companies,"POLÍTICA: Permitir que super_admins atualizem qualquer empresa | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: companies,"POLÍTICA: Affiliates can only see their own clients | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): ((( SELECT admin_users.role
   FROM admin_users
  WHERE (admin_users.id = auth.uid())) = 'super_admin'::text) OR (affiliate_id = ( SELECT admin_users.affiliate_id
   FROM admin_users
  WHERE (admin_users.id = auth.uid())))) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: companies,"POLÍTICA: Allow users to update their own company | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())) = id) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: companies,POLÍTICA: Usuários podem ver os dados da sua própria empresa | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (id = get_my_company_id()) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: companies,"POLÍTICA: Permitir que super_admins leiam qualquer empresa | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: companies,"POLÍTICA: Authenticated users can view their own company | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: company_secrets,POLÍTICA: Usuários só podem acessar os segredos da sua própria empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = get_my_company_id()) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: company_secrets,POLÍTICA: Usuários só podem aceder aos segredos da sua própria empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = get_my_company_id()) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: company_secrets,POLÍTICA: Allow company members to access their own secrets | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = app_auth.get_current_company_id()) | VERIFICANDO (WITH CHECK): (company_id = app_auth.get_current_company_id())
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: company_user_details_sync,"POLÍTICA: Allow admins view affiliated SYNC | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): ((( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'admin'::text) AND (affiliate_id = auth.uid())) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: company_user_details_sync,"POLÍTICA: Allow super_admins full access SYNC | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: coupons,"POLÍTICA: Permitir acesso total de superadmins aos cupons | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: coupons,POLÍTICA: Permitir que usuários autenticados leiam cupons ativos | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): (is_active = true) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: documents,"POLÍTICA: Isolamento total por empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())))"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: events,POLÍTICA: Permitir acesso total aos eventos da própria empresa | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = get_my_company_id()) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: ingestion_queue,"POLÍTICA: Permitir utilizadores autenticados criar tarefas de ingestão | COMANDO: INSERT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): N/A | VERIFICANDO (WITH CHECK): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())))"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: legal_documents,"POLÍTICA: Allow super_admins to update | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: legal_documents,"POLÍTICA: Allow super_admins to manage documents | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text)"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: legal_documents,POLÍTICA: Allow public read access | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): true | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: plans,"POLÍTICA: Allow admins and super_admins full access to plans | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = ANY (ARRAY['admin'::text, 'super_admin'::text])) | VERIFICANDO (WITH CHECK): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = ANY (ARRAY['admin'::text, 'super_admin'::text]))"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: plans,POLÍTICA: Allow authenticated users to read plans | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: authenticated | USANDO (USING): true | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: products,"POLÍTICA: Allow insert for own company products | COMANDO: INSERT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): N/A | VERIFICANDO (WITH CHECK): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())))"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: products,"POLÍTICA: Allow delete for own company products | COMANDO: DELETE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: products,"POLÍTICA: Users can manage their own company's products | COMANDO: ALL | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid())))"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: products,"POLÍTICA: Allow read access to own company products | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: products,"POLÍTICA: Allow update for own company products | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (company_id = ( SELECT users.company_id
   FROM users
  WHERE (users.id = auth.uid()))) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: terms_acceptances,POLÍTICA: Allow users to read their own acceptance | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (auth.uid() = user_id) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: terms_acceptances,POLÍTICA: Allow users to insert their own acceptance | COMANDO: INSERT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): N/A | VERIFICANDO (WITH CHECK): (auth.uid() = user_id)
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: terms_acceptances,"POLÍTICA: Allow super_admins to read all acceptances | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'super_admin'::text) | VERIFICANDO (WITH CHECK): N/A"
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: users,POLÍTICA: Permitir ao usuário atualizar seus próprios dados | COMANDO: UPDATE | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (auth.uid() = id) | VERIFICANDO (WITH CHECK): N/A
6. POLÍTICAS DE SEGURANÇA (RLS),TABELA: users,POLÍTICA: Permitir ao usuário ler seus próprios dados | COMANDO: SELECT | PERMISSÃO: PERMISSIVE | PARA: public | USANDO (USING): (auth.uid() = id) | VERIFICANDO (WITH CHECK): N/A